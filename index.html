<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The 1 to 20 Game v2.4</title>
    <style>
        :root {
            --color-background: #121212; 
            --color-container-bg: #1e1e1e; 
            --color-text-primary: #e0e0e0; 
            --color-text-secondary: #888; 
            --color-accent: #9b7de2; 
            --color-accent-dark: #8166c1; 
            --color-accent-light: #2a2536; 
            --color-primary-button: #3685e0; 
            --color-primary-button-hover: #58a6ff; 
            --color-danger: #dc3545; 
            --color-success: #28a745; 
            --color-button-disabled-bg: #444; 
            --color-shadow: rgba(0, 0, 0, 0.4); 
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body {
            font-family: var(--font-main); 
            background-color: var(--color-background); 
            color: var(--color-text-primary); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0; 
            padding: 20px; 
            box-sizing: border-box; 
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            width: 100%; 
            max-width: 420px; 
            text-align: center;
        }
        .game-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            height: 44px; /* Maintain height for consistent spacing */
        }
        h1 {
            color: var(--color-text-primary); 
            font-size: 2rem; 
            margin: 0; 
            white-space: nowrap;
        }
        #game-container {
            background-color: var(--color-container-bg); 
            border-radius: 16px; 
            box-shadow: 0 8px 32px var(--color-shadow); 
            padding: 2rem; 
            transition: background-color 0.3s; 
            display: flex; 
            flex-direction: column;
        }
        body:fullscreen .game-header {
            display: none;
        }
        #ai-status-wrapper {
            background-color: var(--color-accent-light); 
            border-left: 5px solid var(--color-accent); 
            padding: 1rem 1.5rem; 
            margin-bottom: 2rem; 
            border-radius: 8px; 
            min-height: 80px; /* Fixed height for 2 lines of text + padding */
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 10px;
        }
        #ai-status {
            font-style: italic; 
            font-size: 1.2rem; 
            color: var(--color-text-primary); 
            line-height: 1.5;
        }
        .typing-indicator { 
            font-weight: bold; 
            animation: blink 1.2s infinite; 
        }
        @keyframes blink { 
            50% { opacity: 0; } 
        }
        #current-count {
            font-size: 7rem; 
            font-weight: bold; 
            color: var(--color-accent); 
            margin-bottom: 2rem;
        }
        #player-actions {
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 1rem; 
            margin-bottom: 2rem;
        }
        .action-btn {
            background-color: var(--color-accent); 
            color: #ffffff; 
            border: none; 
            border-radius: 8px; 
            font-size: 2.5rem; 
            font-weight: bold; 
            cursor: pointer; 
            transition: all 0.2s; 
            aspect-ratio: 1 / 1; 
            display: flex; 
            justify-content: center; 
            align-items: center;
        }
        .action-btn:hover:not(:disabled) {
            background-color: var(--color-accent-dark); 
            transform: translateY(-3px);
        }
        .action-btn:disabled {
            background-color: var(--color-button-disabled-bg); 
            color: #ffffffc0; 
            cursor: not-allowed; 
            transform: none; 
            opacity: 0.5;
        }
        #game-controls { 
            display: grid; 
            grid-template-columns: 1fr; 
            align-items: center; 
            gap: 1rem; 
        }
        .control-group { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 5px; 
        }
        #difficulty-select { 
            padding: 0.8rem; 
            border-radius: 8px; 
            width: 100%; 
            border: 2px solid var(--color-accent-light); 
            background-color: var(--color-container-bg); 
            color: var(--color-text-primary); 
            font-size: 1rem; 
            font-weight: bold; 
            text-align: center; 
        }
        #start-restart-btn {
            background-color: var(--color-primary-button); 
            color: white; 
            border: none; 
            padding: 1rem; 
            border-radius: 12px; 
            font-size: 1.2rem; 
            font-weight: bold; 
            cursor: pointer; 
            width: 100%; 
            transition: background-color 0.2s;
        }
        #game-over-modal {
            position: fixed; 
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0; 
            background-color: rgba(0, 0, 0, 0.7); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            z-index: 20; 
            opacity: 0; 
            pointer-events: none; 
            transition: opacity 0.4s ease;
        }
        #game-over-modal.visible { 
            opacity: 1; 
            pointer-events: auto; 
        }
        .modal-content {
            background-color: var(--color-container-bg); 
            padding: 2rem; 
            border-radius: 16px; 
            text-align: center; 
            box-shadow: 0 5px 15px var(--color-shadow); 
            transform: scale(0.9); 
            transition: transform 0.4s ease; 
            width: 90%; 
            max-width: 400px;
        }
        #game-over-modal.visible .modal-content { 
            transform: scale(1); 
        }
        .modal-content h2 { 
            font-size: 2.5rem; 
            margin: 0 0 1rem 0; 
        }
        .modal-content p { 
            font-size: 1.1rem; 
            line-height: 1.6; 
            color: var(--color-text-secondary); 
            margin-bottom: 2rem; 
        }
        #play-again-btn {
            background-color: var(--color-accent); 
            color: white; 
            border: none; 
            padding: 1rem 2rem; 
            border-radius: 12px; 
            font-size: 1.2rem; 
            cursor: pointer; 
            transition: background-color 0.2s;
        }
        #play-again-btn:hover { 
            background-color: var(--color-accent-dark); 
        }
        
        @media (max-width: 500px) {
            body { 
                padding: 10px; 
            }
            h1 { 
                font-size: 1.6rem; 
            }
            #game-container { 
                padding: 1.5rem; 
            }
            #current-count { 
                font-size: 6rem; 
            }
            .action-btn { 
                font-size: 2rem; 
            }
            #ai-status { 
                font-size: 1rem; 
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="game-header">
            <h1>The 1 to 20 Game</h1>
        </header>

        <div id="game-container">
            <div id="ai-status-wrapper">
                <span id="ai-status"></span>
            </div>
            <div id="current-count">0</div>
            <div id="player-actions">
                <button class="action-btn" data-move="1">1</button>
                <button class="action-btn" data-move="2">2</button>
                <button class="action-btn" data-move="3">3</button>
            </div>
            <div id="game-controls">
                <div class="control-group">
                    <label for="difficulty-select">Difficulty</label>
                    <select id="difficulty-select">
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard" selected>Hard</option>
                    </select>
                </div>
                <button id="start-restart-btn">Start Game</button>
            </div>
        </div>
    </div>
    
    <div id="game-over-modal">
        <div class="modal-content">
            <h2 id="modal-title"></h2>
            <p id="modal-message"></p>
            <button id="play-again-btn">Play Again</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                aiStatusBox: document.getElementById('ai-status'),
                currentCountDisplay: document.getElementById('current-count'),
                playerActionButtons: document.querySelectorAll('.action-btn'),
                difficultySelect: document.getElementById('difficulty-select'),
                startRestartBtn: document.getElementById('start-restart-btn'),
                gameOverModal: document.getElementById('game-over-modal'),
                modalTitle: document.getElementById('modal-title'),
                modalMessage: document.getElementById('modal-message'),
                playAgainBtn: document.getElementById('play-again-btn')
            };

            let currentCount = 0, playerTurn = true, gameOver = true, aiDifficulty = 'hard', usedDialogue = {};
            let lastPlayerMove = 0, playerMadeMistake = false;
            let currentPersonality;

            const personalities = {
                analyst: {
                    name: 'Analyst',
                    dialogue: {
                        waiting: [ "Select a difficulty and press Start.", "Ready when you are...", "The path to 20 awaits.", "Choose your difficulty.", "Awaiting input.", "The board is set. The pieces are moving." ],
                        start: [ "The game begins. You may go first.", "You may begin.", "Let's see what you've got.", "I'll allow you the first move.", "Show me your strategy." ],
                        aiStart: [ "I'll take the lead this time.", "My turn to start.", "Let's begin. I'll go first.", "I'll set the pace. Try to keep up.", "My calculations suggest I should start." ],
                        thinking: [ "Hmm...", "Let me see...", "Calculating...", "Interesting...", "Just a moment...", "Evaluating possibilities...", "The optimal move is...", "Compiling response..." ],
                        playerPrompt: [ "Your move.", "Your turn.", "What will you do?", "Make your move.", "I'm waiting.", "The board is yours.", "Your decision?" ],
                        playerMistake: [ "An interesting choice.", "I see an opening now.", "Are you sure about that?", "A sub-optimal move.", "Just as I predicted.", "A blunder. A costly one.", "A fatal error has been made." ],
                        playerGoodMove: [ "Well played.", "A clever move.", "You've blocked my path, for now.", "I see you know the strategy.", "A formidable move.", "Not bad. Not bad at all.", "You've studied the game, I see." ],
                        winningMove: [ "That sets me up perfectly.", "A perfect calculation.", "The path to victory is clear.", "And that should be game.", "Precisely as I planned.", "The final piece falls into place.", "The game is now concluded." ],
                        aiLosingMove: ["Go on then. Finish it.", "I've made a miscalculation. Enjoy this.", "Hmph. You've got me. This time.", "I see my fate. Play your final number."],
                        tieBreaker: [ "You've left it to chance.", "A risky position. Let's see...", "This could go either way.", "An unpredictable state.", "Down to pure chance." ],
                        aiWin: [ "A logical conclusion. Victory is mine.", "A predictable outcome.", "Better luck next time.", "Checkmate.", "The logical outcome has been achieved." ],
                        aiWinByMistake: ["Your choice of {move} was a fatal error.", "The moment you chose {move}, you lost.", "I win. Your mistake was your undoing."],
                        playerWin: [ "You've bested me. I won't make that mistake again.", "A surprising victory. Well done.", "You have my congratulations.", "I'll get you next time." ],
                        playerWinPerfect: ["Incredible. You played a perfect game.", "Not a single mistake. My congratulations.", "I couldn't find an opening. Well played."]
                    }
                },
                rival: {
                    name: 'Rival',
                    dialogue: {
                        waiting: [ "Are you going to press start or just stare?", "Come on, I don't have all day!", "Difficulty? Just pick Hard, unless you're scared.", "Let's go! Or are you already giving up?" ],
                        start: [ "Alright, you first. Don't mess it up.", "You start. Let's see if you've learned anything.", "Go ahead. I like a challenge." ],
                        aiStart: [ "My turn to start! Try and keep up.", "I'm starting. This'll be over before you know it.", "I'll take the lead. You'll be playing catch-up.", "Let's get this done. I'm going first." ],
                        thinking: [ "Heh...", "Too easy.", "Is that all you've got?", "Predictable.", "Really? That's your move?", "Let me think... not that I need to." ],
                        playerPrompt: [ "Your move, slowpoke.", "Hurry up!", "What's the hold up?", "Your turn. Try not to blow it.", "Still thinking? It's not that hard." ],
                        playerMistake: [ "YES! That's the mistake I was waiting for!", "Oh, you just handed me the game.", "Was that on purpose? Seriously?", "And that's where you lose the game.", "You really stepped in it that time." ],
                        playerGoodMove: [ "Tch. Lucky move.", "Not bad... for you.", "That only delays the inevitable.", "I'll admit, that was annoying.", "So you DO know how to play." ],
                        winningMove: [ "And that's checkmate. Too easy!", "This is it! The final blow!", "You're finished!", "This is how a real winner plays.", "And I'll take that for the win!" ],
                        aiLosingMove: ["No! It can't be!", "Ugh, fine, you win this time.", "Don't get cocky. This was a fluke.", "Just finish it already..."],
                        tieBreaker: [ "You're just getting lucky now.", "Hmph. Let's see what happens.", "This is just leaving it to chance, how boring." ],
                        aiWin: [ "Of course I won. Was there ever any doubt?", "Better luck next time, rookie!", "Get good. Then maybe we can talk.", "I am the champion! Obviously." ],
                        aiWinByMistake: ["You chose {move}? Haha, thanks for the free win!", "That move, {move}, was your last.", "You choked! I'll take it!"],
                        playerWin: [ "You got lucky! That's all!", "Next time, I won't go so easy on you.", "This isn't over! I demand a rematch!", "I wasn't even trying." ],
                        playerWinPerfect: ["What... How did you...?", "A perfect game? No way!", "You must have cheated!"]
                    }
                },
                sage: {
                    name: 'Sage',
                    dialogue: {
                        waiting: [ "The first step on a long journey begins with 'Start'.", "Patience. The game awaits the ready student.", "Choose the path that reflects your current skill.", "The numbers hold a lesson for you." ],
                        start: [ "Your journey begins. May you learn from it.", "The first move is yours. What will it teach us?", "Begin. Show me the path you will walk." ],
                        aiStart: [ "I shall begin, to demonstrate the way.", "Let the first move be a lesson.", "The first number is spoken. The path unfolds.", "Observe, and learn." ],
                        thinking: [ "The currents of fate are shifting...", "I see the path forward.", "What does this move signify?", "Pondering the sequence...", "Every number has a purpose." ],
                        playerPrompt: [ "The turn is yours, young grasshopper.", "What is your next step on this path?", "The choice is yours to make.", "How will you proceed?", "Speak your intention." ],
                        playerMistake: [ "A hasty decision leads to a difficult path.", "Consider the consequences of your actions.", "That move has created a ripple you did not intend.", "Every mistake is a lesson in disguise." ],
                        playerGoodMove: [ "A wise choice. You see the pattern.", "You have found the flow of the game.", "Excellent. You feel the rhythm of the numbers.", "You have blocked my path, as a river blocks a stone." ],
                        winningMove: [ "And so, the lesson concludes.", "The path has led to this moment.", "The outcome was written in the numbers.", "Thus, the game finds its end.", "A predictable, yet satisfying conclusion." ],
aiLosingMove: ["The student has become the master.", "My path ends here. Yours continues.", "Well done. Take your final step to victory.", "I accept this outcome."],
                        tieBreaker: [ "We arrive at a crossroads of chance.", "Fate will now decide the victor.", "The path has diverged. Let's see where it leads." ],
                        aiWin: [ "The lesson is over. Meditate on what you have learned.", "Victory is not the goal, but the journey.", "You played well, but the path was clearer to me.", "Do not be discouraged by this outcome." ],
                        aiWinByMistake: ["Your choice of {move} was a lesson in haste.", "When you chose {move}, the path closed for you.", "The game ended when your focus slipped."],
                        playerWin: [ "You have learned the lesson of the numbers. Well done.", "A victory well earned.", "The student surpasses the master.", "Your focus was true. Congratulations." ],
                        playerWinPerfect: ["You have achieved a perfect understanding.", "Your mind and the numbers were as one.", "A flawless execution. I am impressed."]
                    }
                },
                flustered: {
                    name: 'Flustered',
                    dialogue: {
                        waiting: [ "Oh, um, hi! Ready when you are, I guess.", "Just pick a... a thingy. A difficulty. No pressure!", "Is it my turn yet? Oh, right, you have to start." ],
                        start: [ "Okay, you can go first. Phew.", "You start! I'm... still booting up.", "Here we go! Good luck! To both of us!" ],
                        aiStart: [ "ME?! Oh, okay, I'll start! Um... one!", "I'll go! Let's try... this one!", "Okay okay okay, my turn, here I go!" ],
                        thinking: [ "BEEP BOOP... Is this right?", "Wait, carry the one...", "My processors are overheating!", "Uh oh.", "Does not compute! Does not compute!", "Thinking... please wait..." ],
                        playerPrompt: [ "Your turn! I think!", "Um, you can go now.", "What's your move? It's okay, take your time.", "I'm ready! I think." ],
                        playerMistake: [ "Oh! I think I see a thing!", "Is that a mistake? Maybe! I'll take it!", "Wait, that move... my circuits are buzzing!", "I think that's good for me! Yay!" ],
                        playerGoodMove: [ "Oh, shoot. You're good at this.", "Drats. You blocked me.", "Wow, good move! How'd you see that?", "My poor circuits... that was a good move." ],
                        winningMove: [ "I think... I think I'm going to win!", "YES! I DID IT!", "Is this the winning move? I hope so!", "This is it! I'm going for it!" ],
                        aiLosingMove: ["Oh no, I messed up!", "I knew it! I'm no good at this game!", "You're too good! It's not fair!", "Just... just take the win."],
                        tieBreaker: [ "Eeny, meeny, miny, moe...", "I'll just pick one and hope!", "I can't look! Is it a good move?" ],
                        aiWin: [ "I WON! I can't believe it! Did you see?!", "Wow! I actually won! Hooray!", "Did I... did I win? Yes! Awesome!" ],
                        aiWinByMistake: ["You picked {move}, and then my lights went all blinky! I win!", "Your move {move} made it easy! Thanks!"],
                        playerWin: [ "Aw, you won! Good game!", "You're really good at this! Congratulations!", "I lost again! But that was fun!", "Congrats! You're the winner!" ],
                        playerWinPerfect: ["WOW! A perfect game!", "You're like a super computer!", "That was amazing! You didn't make any mistakes!"]
                    }
                }
            };
            
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            const calculateReadingTime = (text) => {
                const wordsPerMinute = 240;
                const words = text.split(' ').filter(word => word.length > 0).length;
                const time = Math.ceil((words / wordsPerMinute) * 60 * 1000);
                const baseDelay = 400;
                const randomFactor = Math.random() * 250;
                return baseDelay + time + randomFactor;
            };

            const initGame = () => {
                gameOver = true; currentCount = 0; playerTurn = true; usedDialogue = {};
                ui.difficultySelect.disabled = false;
                ui.currentCountDisplay.textContent = currentCount;
                ui.gameOverModal.classList.remove('visible');
                ui.startRestartBtn.textContent = "Start Game";
                displayAiMessage('waiting');
                updatePlayerActionButtons();
            };
            
            const startGame = async () => {
                gameOver = false; usedDialogue = {}; playerMadeMistake = false;
                const personalityKeys = Object.keys(personalities);
                currentPersonality = personalities[personalityKeys[Math.floor(Math.random() * personalityKeys.length)]];
                
                aiDifficulty = ui.difficultySelect.value;
                ui.difficultySelect.disabled = true;
                ui.startRestartBtn.textContent = "Restart Game";
                
                if (Math.random() > 0.5) {
                    playerTurn = true;
                    const msg = getRandomMessage('start');
                    await displayAiMessage(msg);
                } else {
                    playerTurn = false;
                    const msg = getRandomMessage('aiStart');
                    await displayAiMessage(msg);
                    await aiTurn();
                }
                updatePlayerActionButtons();
            };

            const playerMove = async (numCount) => {
                if (!playerTurn || gameOver) return;
                playerTurn = false;
                lastPlayerMove = numCount;
                updateGame(currentCount + numCount);

                if (currentCount >= 20) {
                    await sleep(500);
                    endGame('Player');
                    return;
                }

                let reactionCategory = null;
                if (isPlayerMistake()) {
                    reactionCategory = 'playerMistake';
                    playerMadeMistake = true;
                } else if (isMultipleOfFour(currentCount)) {
                    reactionCategory = 'playerGoodMove';
                }

                if (reactionCategory) {
                    const msg = getRandomMessage(reactionCategory);
                    await displayAiMessage(msg);
                }
                
                await aiTurn();
            };
            
            const aiTurn = async () => {
                if (gameOver) return;
                
                const thinkingMsg = getRandomMessage('thinking');
                await displayAiMessage(thinkingMsg, true, null, 1000 + Math.random() * 500);

                const { move, wasOptimal } = getAiMove();
                let numbersToSay = move;
                if (currentCount + numbersToSay > 20) {
                    numbersToSay = 20 - currentCount;
                }
                const isWinningMove = isMultipleOfFour(currentCount + numbersToSay) && numbersToSay > 0 && wasOptimal;

                let actionMsgCategory = null;
                if (isWinningMove) {
                    actionMsgCategory = 'winningMove';
                } else if (currentCount > 16 && move > 0) {
                    actionMsgCategory = 'aiLosingMove';
                } else if (wasOptimal === false && getOptimalMove().move !== 0) {
                    actionMsgCategory = 'tieBreaker';
                }

                if(actionMsgCategory){
                    const msg = getRandomMessage(actionMsgCategory);
                    await displayAiMessage(msg);
                }

                updateGame(currentCount + numbersToSay);

                if (currentCount >= 20) {
                    await sleep(500);
                    endGame('AI');
                    return;
                }
                
                playerTurn = true;
                const promptMsg = getRandomMessage('playerPrompt');
                displayAiMessage(promptMsg);
                updatePlayerActionButtons();
            };

            const getAiMove = () => {
                const playOptimal = Math.random() < { 'easy': 0.2, 'medium': 0.6, 'hard': 0.95 }[aiDifficulty];
                if (playOptimal) {
                    const optimalMove = getOptimalMove();
                    if (optimalMove.move !== 0) return optimalMove;
                }
                return { move: getRandomMove(), wasOptimal: false };
            };

            const getOptimalMove = () => {
                const remainder = currentCount % 4;
                if (remainder === 0) {
                    return { move: 0, wasOptimal: false };
                }
                return { move: 4 - remainder, wasOptimal: true };
            };

            const getRandomMove = () => Math.floor(Math.random() * 3) + 1;
            const isMultipleOfFour = (num) => num > 0 && num % 4 === 0;
            const isPlayerMistake = () => [1, 2, 3].some(i => isMultipleOfFour(currentCount + i) && currentCount + i <= 20);

            const updateGame = (newCount) => {
                currentCount = newCount;
                ui.currentCountDisplay.textContent = newCount;
                updatePlayerActionButtons();
            };

            const endGame = (winner) => {
                gameOver = true; playerTurn = false;
                updatePlayerActionButtons();
                ui.difficultySelect.disabled = false;
                let title;
                let message;

                if (winner === 'AI') {
                    title = "You Lost";
                    let category = playerMadeMistake ? 'aiWinByMistake' : 'aiWin';
                    message = getRandomMessage(category, { move: lastPlayerMove });
                    ui.modalTitle.style.color = 'var(--color-danger)';
                } else {
                    title = "You Win!";
                    let category = !playerMadeMistake && aiDifficulty === 'hard' ? 'playerWinPerfect' : 'playerWin';
                    message = getRandomMessage(category);
                    ui.modalTitle.style.color = 'var(--color-success)';
                }
                ui.modalTitle.textContent = title; 
                ui.modalMessage.textContent = message;
                setTimeout(() => ui.gameOverModal.classList.add('visible'), 500);
            };

            const updatePlayerActionButtons = () => {
                ui.playerActionButtons.forEach(button => {
                    const moveCount = parseInt(button.dataset.move, 10);
                    const potentialCount = currentCount + moveCount;
                    
                    if (potentialCount > 20 || gameOver) {
                        button.textContent = (potentialCount > 20 && !gameOver) ? potentialCount : 'X';
                        if (potentialCount > 20) button.textContent = 'X';
                        button.disabled = true;
                    } else {
                        button.textContent = potentialCount;
                        button.disabled = !playerTurn;
                    }
                });
            };
            
            const displayAiMessage = async (categoryOrMessage, isThinking = false, context = null, thinkingTime = 0) => {
                let message = categoryOrMessage;
                // It's a category if it exists in the dialogue map, otherwise it's a direct message.
                if (currentPersonality && currentPersonality.dialogue[categoryOrMessage]) {
                    message = getRandomMessage(categoryOrMessage, context);
                } else if (context) {
                    // Handle placeholder replacement for direct messages too
                    message = message.replace(/\{(\w+)\}/g, (placeholder, key) => context[key] !== undefined ? context[key] : placeholder);
                }
                
                ui.aiStatusBox.innerHTML = message + (isThinking ? `<span class="typing-indicator">...</span>` : '');
                
                if (isThinking) {
                    await sleep(thinkingTime);
                } else {
                    await sleep(calculateReadingTime(message));
                }
            };
            
            const getRandomMessage = (category, context = null) => {
                if (!currentPersonality) {
                    // Default to analyst if no personality is set (e.g., waiting screen)
                    currentPersonality = personalities.analyst;
                }

                const allMessages = currentPersonality.dialogue[category];
                if (!allMessages) return ""; // Failsafe

                if (!usedDialogue[category]) {
                    usedDialogue[category] = [];
                }
                
                let availableIndices = allMessages.map((_, i) => i).filter(i => !usedDialogue[category].includes(i));
                
                if (availableIndices.length === 0) {
                    usedDialogue[category] = []; // Reset if all have been used
                    availableIndices = allMessages.map((_, i) => i);
                }
                
                const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                usedDialogue[category].push(randomIndex);
                
                let message = allMessages[randomIndex];

                if (context) {
                    message = message.replace(/\{(\w+)\}/g, (placeholder, key) => {
                        return context[key] !== undefined ? `<strong>${context[key]}</strong>` : placeholder;
                    });
                }
                
                return message;
            };

            const toggleFullScreen = () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {});
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            };

            document.addEventListener('keydown', (e) => {
                if (ui.gameOverModal.classList.contains('visible')) return;
                if (e.key.toLowerCase() === 'f' && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    toggleFullScreen();
                }
            });

            ui.playerActionButtons.forEach(button => {
                button.addEventListener('click', () => playerMove(parseInt(button.dataset.move, 10)));
            });
            ui.startRestartBtn.addEventListener('click', () => gameOver ? startGame() : initGame());
            ui.playAgainBtn.addEventListener('click', initGame);

            initGame();
        });
    </script>
</body>
</html>